package api

import (
	"context"
	"encoding/json"
	"regexp"
)

type DataService interface {
	Room(context.Context, string) (Room, error)
	DriverMapping(context.Context) (DriverMapping, error)
}

// DriverMapping looks like this
/*
{
	"via-connect-pro": {
		"baseURLs": {
			"default": "http://localhost:8012",
			"k8s": "http://via-service.service",
		}
	},
	"sony-tv": {
		"baseURLs": {
			"default": "http://localhost:8016",
			"k8s": "http://sony-tv.service",
		}
	}
}
*/
// Does NOT come from driver library
// comes from our autogenerated server (grpc func)
// http://localhost:8012/{{address}}/capabilities
/*
[
	"SetPower", // av-api hard coded this = baseURL + "/{{address}}/SetPower/", or GRPC: call SetPower(ctx, address, power)
	"GetPower",
	"SetInput",
	"GetInput"
]
*/
type DriverMapping map[string]struct {
	BaseURLs map[string]string `json:"BaseURLs"`
}

type Room struct {
	ID      string   `json:"id"`
	Devices []Device `json:"devices"`
}

type Device struct {
	ID      DeviceID                  `json:"id"`
	Type    string                    `json:"type"`
	Address string                    `json:"address"`
	Proxy   map[*regexp.Regexp]string `json:"-"`
	Ports   Ports                     `json:"ports,omitempty"`
}

// Port I think? this will only be used on DSP 's ??
type Port struct {
	Name string `json:"name"`
	Type string `json:"type"`
}

type Ports []Port

func (d Device) MarshalJSON() ([]byte, error) {
	type Alias Device

	changed := struct {
		*Alias
		Proxy map[string]string `json:"proxy,omitempty"`
	}{
		Alias: (*Alias)(&d),
		Proxy: make(map[string]string),
	}

	for k, v := range d.Proxy {
		changed.Proxy[k.String()] = v
	}

	return json.Marshal(changed)
}
