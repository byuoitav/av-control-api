# Overview

Understanding the internal workings of the AV API Service (hereafter referred to as "the API") necessitate the understanding of some of the structs. While names reflect usage some definitions aid in understanding further documentation.

Each section defines a logical struct, as well as a brief description/justification for it's use.

### Public Room

The main logical unit used in the API. This is separate from a **Room**, which is used internally. The Public Room represents the properties of a physical room exposed through the API.

Public Room, however, is not a strict subset of a **Room**. Devices within the room are separated into the general categories of "Display" and "Audio Device" within a Public Room, this division is not apparent in a **Room** object.

[LinkToCode](blablah.html)

### Room
> Note: This may be renamed to 'internal room' or efforts may be taken to reconcile the two structures.

This is the internal room object that represents all information necessary to execute actions against the room.

A Room contains:

* a **Room Configuration**
* a set of **Commands** available for the room
* and a set of **Devices** contained within the room


[LinkToCode](blablah.html)

### Command

A command takes the form of an endpoint and a microservice address used to send a command to a device.

The current list of possible commands include

* PowerOn (Turn device on)
* Standby (Place device into standby)
* ChangeInput
* SetVolume
* Blank Screen
* UnBlankScreen
* Mute
* Unmute

Some command require parameters (SetVolume and ChangeInput) while others do not (PowerOn and Mute)

Parameters for a command are denoted in the endpoint field of the command. They take the form of `:<Parameter name>`. When the command is being executed these placeholders in the endpoint will be replaced by parameters from the `params` map in the **Action Structure**

### Room Configuration

A Room Configuration represents the logical rules that govern the interaction with a room. In our paradigm that takes the form of a set of links to implementations of the **Command Evaluator** interfaces. This set determines the behavior of each command for rooms with this configuration. (e.g. Scaling of volume levels from Max=100 to Max==70)

Each Room configuration also contains a link to an implementation of the **Action Reconciler** interface. This is used to determine the interaction of commands within this room. (e.g. always turn Device1 off before Device2)


### Command Evaluator
>Familiarity with  [interfaces](https://golang.org/doc/effective_go.html#interfaces_and_types) is helpful to understanding this section

Command Evaluator is an interface with three methods, each with a different purpose

1. Evaluate
1. Validate
1. GetIncompatableActions


##### Evalaute

`Evaluate(base.PublicRoom) ([]ActionStructure, error)`

Evaluate accepts a **Public Room** and returns a list of **ActionStructure** objects.

The primary purpose of the evaluate command is to generate commands and parameters for evaluation from a **Public Room** and map them to a device. It is not the purpose of the evaluation to determine if the command and parameter are valid for the device in question.

Evaluate can also perform configuration-specific mappings for commands and parameters. (e.g. scaling volume levels)

##### Validate

`Validate(ActionStructure) error`

Validate accepts an **ActionStructure** object and determines if the command and parameter are valid for the device specified.

##### GetIncompatableActions

`GetIncompatibleCommands() []string`

GetIncompatibleCommands will return a list of commands that are incompatable (cannot be issued at the same time) as commands generated by the CommandEvaluator. This is available for use in the reconciler.  

### Action Reconciler
>Familiarity with  [interfaces](https://golang.org/doc/effective_go.html#interfaces_and_types) is helpful to understanding this section

An action reconciler is an interface containing one function

1. Reconcile

##### Reconcile

`Reconcile([]ActionStructure) [([]ActionStructure, error)`

Reconcile takes a slice of **ActionStructure** objects, and returns an ordered list of the same.

It is the purpose of the reconcile function to allow control of the interplay of commands within a room (order of execution, mutually exclusive commands, etc.)

The **ActionStructure** elements will be evaluated (executed) in the order returned from Reconcile.

### Action Structure

An Action Structure is an internal construct containing information necessary to the validation and execution of a specific **command** against a specific device.

It contains the following properties:

|Property Name| Short Description |
|---|---|
|Name | This corresponds to a **command** name. |
|DeviceSpecific | A boolean denoting if the **Action Structure** was generated as part of a room wide-property (`false`) or a device-specific property (`true`)|
|Device | The device for the **Action Structure** to be evaluated against.|
|Overridden| A boolean denoting if this **Action Structure** has been overridden by another.|
|Params | A map linking **command** parameters to values.|




































1. Get room configuration for room from Database
  - Configuration contains a `Reconcile()` action
  - Configuration contains commands for the configuration
    - Each command contains
      - Priority
      - `Evaluate()` and `Validate()` action
1. Order commands in the configuration based on priority
1. For each command call:
  1. `Evaluate()`
    - `Evaluate()` takes a the information in the PUT body + room information and returns a list of actions corresponding to that command.
        - Can perform any sort of inner-command logic required for the configuration (i.e. scaling volume levels)
        - Each action contains
          - A device
          - A command name
          - A set of parameters (if necessary for the action)
  1. `Validate()`
        - `Validate()` takes the list of commands and checks if the commands/parameters are valid for the device specified. Returns true/false
        - If validate returns true, add to compiled list of actions from all commands
1. Once list of actions has been compiled for all commands in the configuration, call `Reconcile()`
    - `Reconcile()` takes the list of actions and can perform any sort of checking, reordering, or any other configuration specific actions that are inter-action, and returns an ordered list of actions. (the logic is dependent on the interplay of actions/commands. i.e. Always turn D1 on before D2)
1. For each action in the list, execute it.
1. Return new state + report of actions taken.






















### Mapping state to commands

The AV API is a RESTful service. Interaction occurs by requesting and setting the state of resources. Sending a PUT request with the JSON payload of:

```
{
  "displays": [{
      "name": "D1",
      "power": "on"
    }]  
}
```

To the endpoint `/buildings/ITB/rooms/1001D` is saying "in room 1001D in the ITB, set the power state of display D1 to on."

It is the purpose of the AV API to generate, and then execute the **command** (or commands) required to place the room into the state requested by the user. In the AV API commands are executed by calling RPC endpoints on microservices that correspond to a command and protocol.

Thus the body

```
{
  "displays": [{
      "name": "D1",
      "power": "on"
    }]  
}
```

Must be translated to the command:

```
  http://sony-control-microservice/10.10.10.10/power/on
```

Implying the intermediary mappings of

1. Device `D1` in room `ITB-1001D` is a device that can be communicated with via the `sony-control-microservice`.
1. Device `D1` has address of `10.10.10.10`
1. The property `power` with the value of `on` corresponds to the command endpoint `power/on`

The AV-API maintains these mappings, as well as any logic surrounding command execution for a given room.



#### Logic surrounding multiple command execution

Let's say that there exists a room `ITB-1001D` containing a London-DSP audio device, 2 Sony TV's, and a projector. For reasons specific to this room

For example the PUT body

```
{
    "power": "on"
}  
```

Sent to the endpoint `/buildings/ITB/rooms/1001D` requests that the entire room's `power` state be set to `on`. In ITB-1001D the room-wide power property aliases to each individual device's power state (for more on customizing command-mapping within a room see <<ROOM CONFIGURATION LINK>>). Thus

```
{
    "power": "on"
}  
```

Must be translated to the set of commands:

```
[
  http://sony-control-microservice/10.10.10.3/power/on,
  http://pjlinkmicroservice/10.10.10.2/power/on,
  http://sony-control-microservice/10.10.10.5/power/on,
  http://londondsp-control-microservice/10.10.10.22/power/on
]
```

The AV-API maintains the logic required to set
